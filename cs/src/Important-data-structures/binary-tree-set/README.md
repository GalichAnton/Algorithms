#   Важнейшие структуры данных: вектор, хеш-таблица, дерево поиска

### 4. Реализация статического двочного дерева, реализующего множество (set) с возможностью поиска

Данный тип реализуется классом BinaryTreeSet и предоставляет собой двоичное дерево поиска, работающее как множество, с возможностью вставки элементов, проверки существования и обхода.

Класс предоставляет следующие методы:

#### 1. Вставка значения

```ts
add(newValue: T): this
```

#### 2. Проверка существования значения

```ts
has(value: T): boolean
```

#### 3. Удаление значения

```ts
remove(value: T): boolean
```

#### 4. Поиск минимального значения (для пустого дерева возвращает null)

```ts
getMin(): Nullable<T>
```

#### 5. Поиск максимального значения (для пустого дерева возвращает null)

```ts
getMax(): Nullable<T>
```

#### 6. Обход дерева в глубину (симметричный)

```ts
inorder(): IterableIterator<T>
```

#### 7. Обход дерева в глубину (прямой)

```ts
preorder(): IterableIterator<T>
```

#### 8. Обход дерева в глубину (обратный)

```ts
postorder(): IterableIterator<T>
```

#### 9. Обход дерева в ширину

```ts
breadsFirst(): IterableIterator<T>
```

#### 10. Очистка дерева

```ts
clear(): void
```

Тип Nullable определяется как

```ts
type Nullable<T> = T | null;
```

Сравнение элементов в операциях вставки, поиска осуществляется приватным методом comparator с сигнатурой вида:

```ts
(value: T, valueToCompare: T) => number;
```

По умолчанию данная функция осуществляет проверку значений на равенство, возвращая в случае равенства 0. Если значения не равны, то производится сравнение через оператор <, при этом возвращается значение 1, если valueToCompare больше, чем value, и -1 в противном случае. При необходимости данную функцию можно переопределить при создании экземпляра класса, передав свою функцию-компаратор в качестве второго аргумента.

Класс реализует интерфейс Iterable (может быть перебран в цикле for...of, развернут оператором spread и т.д.), при этом работает симметричный метод обхода в глубину.

Экземпляр дерева может быть создан из любого перебираемого объекта (реализующего метод Symbol.iterator), переданного в конструктор класса.

Примеры использования:

```js
const bts = new BinaryTreeSet([5, 2, 7]);

bts.add(4);
bts.add(9);

bts.has(2); // true
bts.has(12); // false

bts.getMin(); //2
bts.getMax(); //9

for (const value of bts) {
  console.log(value); // [2, 4, 5, 7, 9]
}

bts.remove(4);

console.log([...bts.inorder()]); // [2, 5, 7, 9]
console.log([...bts.preorder()]); // [5, 2, 7, 9]
console.log([...bts.postorder()]); // [, 2, 9, 7, 5]
console.log([...bts.breadsFirst()]); // [5, 2, 7, 9]
```
