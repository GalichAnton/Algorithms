#  Важнейшие структуры данных: вектор, хеш-таблица, дерево поиска

### 2. Реализация динамического расширяемого массива как вектора

Данный тип реализуется классом Vector и является условной реализацией динамического массива, представляющего собой вектор.

При создании экземпляра класса необходимо передать в конструктор изначальную величину объема буфера (целое положительное число). Далее, при работе с массивом, по мере его наполнения, происходит автоматическое расширение объема буфера (коэффициент расширения задан равным 2, т.е. при нехватке свободных ячеек исходный массив будет расширяться каждый раз вдвое). Буфер реализован нативным массивом JS, без использования встроенных методов.

Класс Vector предоставляет следующие методы для работы с массивом:

#### 1.Получение хранимого значения по его индексу

```ts
get(index: number): Optional<T>
```

#### 2. Добавление значений в конец массива (допускается передача более одного аргумента)

```ts
push(...values: T[]): this
```

#### 3. Извлечение значения с конца массива

```ts
pop(): Optional<T>
```

#### 4. Извлечение значения из начала массива

```ts
shift(): Optional<T>
```

#### 5. Добавление значений в начало массива (допускается передача более одного аргумента)

```ts
unshift(...values: T[]): this
```

#### 6. Удаление/добавление элементов (сигнатура аналогична таковой у метода splice нативного массива JS, поддерживается отрицательная величина индекса)

```ts
splice(start?: number, removeCount?: number, ...values: T[]): Vector<T>
```

#### 7. Отображение элементов массива на новый массив (оригинальный массив не изменяется)

```ts
map<U>(cb: (element: T, index: number, vector: this) => U): Vector<U>
```

#### 8. Фильтрация элементов массива (оригинальный массив не изменяется)

```ts
filter(cb: (element: T, index: number, vector: this) => boolean): Vector<T>
```

#### 9. Преобразование массива в строку посредством объединения элементов задаваемым разделителем (по умолчанию - запятая)

```ts
join(glue: string = ','): string
```

#### 10. Преобразование массива в строку (аналогичен вызову метода join со значением по умолчанию)

```ts
toString(): string
```

#### 11. Получение значение элементов массива

```ts
values(): Generator<T>
```

Тип Optional определяется как

```ts
type Optional<T> = T | undefined;
```

Методы map и filter в качестве аргумента принимают callback-функцию (сигнатура аналогична таковой для нативного массива JS).

Кроме этого у экземпляра массива доступен геттер length:

```ts
get length(): number
```

При добавлении/удалении элементов осуществляется перемещение всех оставшихся элементов в соответствующую сторону для сохранения очередности следования элементов (без пробелов между элементами). Если при добавлении элементов не хватает текущего объема буфера, происходит увеличение объема путем создания нового буфера увеличенного объема и перемещением в него всех существующих элементов.

Массив реализует интерфейс Iterable (может быть перебран в цикле for...of, развернут оператором spread и т.д.).

Примеры использования:

```js
const vector = new Vector(5);

for (let i = 0; i < 5; i += 1) {
  vector.push(i); // [0, 1, 2, 3, 4]
}

vector.get(3); // 3
vector.get(10); // undefined

vector.unshift(7, 8, 9); // [7, 8, 9, 0, 1, 2, 3, 4]

vector.splice(3, 5, 10, 11, 12); // [0, 1, 2, 3, 4]
console.log(vector.join('-')); // '7-8-9-10-11-12'

const mapped = vector.map((element, index, vector) => element - 7); // [0, 1, 2, 3, 4, 5]
const filtered = vector.filter((element, index, vector) => element % 2 !== 0); // [7, 9, 11]

for (const value of vector) {
  console.log(value); // [7, 8, 9, 10, 11, 12, 3, 4]
}
```
