#   Важнейшие структуры данных: вектор, хеш-таблица, дерево поиска

### 1. Реализация динамического расширяемого массива на основе двусвязного двустороннего списка

Данный тип реализуется классом DynamicArray и является условной реализацией динамического массива, построенного на базе двусвязного двунаправленного списка.

Идея реализации состоит в том, что узлы списка хранят ссылки на нативные массивы ограниченной (задаваемой на этапе создания экземпляра класса) длины, которые, в свою очередь, хранят данные. Таким образом, при постепенном заполнении такого массива при необходимости создаются дополнительные узлы списка.

При создании экземпляра класса необходимо передать в конструктор максимальную длину узлового массива (положительное целое число).

Класс DynamicArray предоставляет следующие методы для работы с массивом:

#### 1.Получение хранимого значения по его индексу

```ts
get(index: number): Optional<T>
```

#### 2. Добавление значения в конец массива

```ts
push(value: T): this
```

#### 3. Извлечение значения с конца массива

```ts
pop(): Optional<T>
```

#### 4. Извлечение значения из начала массива

```ts
shift(): Optional<T>
```

#### 5. Добавление значения в начало массива

```ts
unshift(value: T): this
```

#### 6. Отображение элементов массива на новый массив (оригинальный массив не изменяется)

```ts
map<U>(cb: (element: T, index: number, array: this) => U): DynamicArray<U>
```

#### 7. Фильтрация элементов массива (оригинальный массив не изменяется)

```ts
filter(cb: (element: T, index: number, array: this) => boolean): DynamicArray<T>
```

#### 8. Преобразование массива в строку посредством объединения элементов задаваемым разделителем (по умолчанию - запятая)

```ts
join(glue: string = ','): string
```

#### 9. Преобразование массива в строку (аналогичен вызову метода join со значением по умолчанию)

```ts
toString(): string
```

#### 10. Получение значение элементов массива

```ts
values(): Generator<T>
```

Тип Optional определяется как

```ts
type Optional<T> = T | undefined;
```

Методы map и filter в качестве аргумента принимают callback-функцию (сигнатура аналогична таковой для нативного массива JS).

Кроме этого у экземпляра массива доступен геттер length:

```ts
get length(): number
```

При добавлении/удалении элементов со стороны начала массива осуществляется перемещение всех оставшихся элементов в соответствующую сторону для сохранения очередности следования элементов (без пробелов между элементами). Если массив последнего узла после перестановки не содержит ни одного элемента, узел удаляется.

Массив реализует интерфейс Iterable (может быть перебран в цикле for...of, развернут оператором spread и т.д.).

Примеры использования:

```js
const array = new DynamicArray();

array.push(1);
array.push(2);
array.get(0); // 1
array.unshift(3);
array.get(0); // 3

const mapped = array.map((element, index, array) => (index % 2 === 0 ? element : element * 2)); // [6, 1, 4]
const filtered = array.filter((element, index, array) => element < 2); // [1]

console.log(array.join(';')); // '3;1;2'

for (const value of array) {
  console.log(value);
}
```
