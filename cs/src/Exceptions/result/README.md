# Обработка ошибок. Простые и контейнерные типы данных. Функторы и монады

### 1. Реализация контейнерного типа Result с состояниями Ok и Error

Реализация представлена классом Result. Конструктор класса принимает аргументом функцию, возвращающую значение, сохраняемое в создаваемом контейнере. Контейнер может находиться в двух состояниях - наличие валидных данных или ошибка. Для работы с данными контейнера предоставляются методы map, flatMap, catch.

Метод map предназначен для отображения значения контейнера на новое, возвращает новый экземпляр контейнера Result. Метод реализует интерфейс функтора:

```ts
map<V>(mapper: (value: T) => V): Result<V>
```

Метод flatMap предназначен для отображения значения контейнера на новое, упакованное в контейнер Result, возвращает новый экземпляр контейнера Result. Метод реализует интерфейс монады:

```ts
flatMap<V>(mapper: (value: T) => Result<V>): Result<V>
```

Метод catch предназначен для обработки ошибок, возникающих при создании контейнера или отображении его данных:

```ts
catch<V>(errorHandler: (error: Error) => V): Result<V | T>
```

Передача в конструктор класса функции вместо самого значения позволяет перехватывать возможные исключения при выполенении отображения данных в контейнере (код конструктора обёрнут в конструкцию try/catch).

Класс предоставляет статические методы ok и error для создания экземпляров контейнера с данными и ошибкой соответственно:

```ts
static ok<T>(value: T): Result<T>

static error(value: unknown): Result
```

Пример использования:

```js
const result = new Result(() => 1);

// Result { 3 }
const sum = result.map((value) => value + 2);

// Result { 15 }
const prod = sum.flatMap((value) => Result.ok(5));

// TypeError
// Result { 42 }
const err = prod.map((value) => value.trim()).catch(err => {
  console.log(err);
  return 42;
});
```
